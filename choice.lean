/--------------------------------------------------------------\
| Formalization of my 2001 JSL proof that, intuitionistically, |
| choice sets are well-orderable.       Author: J. Todd Wilson |
\--------------------------------------------------------------/

import data.set algebra.order
open set eq.ops prod.ops


-- inductive structures are sets, xs, that are generated by a subset of
-- "initial" elements using a "successor" relation and a "limit" relation

structure ind_str (X : Type) :=
  (xs : set X) (inits : set X) (succ : set (X × X)) (lim : set (set X × X))
  (cl_inits : inits ⊆ xs)
  (cl_succ  : ∀₀ y ∈ xs, ∀ {z}, succ(y,z) → z ∈ xs)
  (cl_lim   : ∀ {Y z}, Y ⊆ xs → lim(Y,z) → z ∈ xs)
  (ind : ∀ X',
    inits ⊆ X' →
    (∀₀ y ∈ X', ∀ {z}, succ(y,z) → z ∈ X') →
    (∀ {Y z}, Y ⊆ X' → lim(Y,z) → z ∈ X') →
      xs ⊆ X')


-- Smullyan induction theorem: Theorem 2.2
 
section
  parameters {X : Type} (I : ind_str X)

  local abbreviation xs       := ind_str.xs I
  local abbreviation inits    := ind_str.inits I
  local abbreviation succ     := ind_str.succ I
  local abbreviation lim      := ind_str.lim I
  local abbreviation cl_inits := ind_str.cl_inits I
  local abbreviation cl_succ  := ind_str.cl_succ I
  local abbreviation cl_lim   := @ind_str.cl_lim X I  -- why do I need X?
  local abbreviation ind      := ind_str.ind I

  theorem ind_str.smullyan_ind (R : set (X × X)) :
    (∀₀ x ∈ xs, ∀₀ x0 ∈ inits, R(x,x0)) →
    (∀₀ x ∈ xs, ∀₀ y ∈ xs, ∀ {z}, R(x,y) → R(y,x) → succ(y,z) → R(x,z)) →
    (∀₀ x ∈ xs, ∀ {Y z}, Y ⊆ xs → (∀₀ y ∈ Y, R(x,y)) → lim(Y,z) → R(x,z)) → 
      ∀₀ x ∈ xs, ∀₀ y ∈ xs, R(x,y) :=
  assume Ha : ∀₀ x ∈ xs, ∀₀ x0 ∈ inits, R(x,x0),
  assume Hb : ∀₀ x ∈ xs, ∀₀ y ∈ xs, ∀ {z}, R(x,y) → R(y,x) → succ(y,z) → R(x,z),
  assume Hc : ∀₀ x ∈ xs, ∀ {Y z}, Y ⊆ xs → (∀₀ y ∈ Y, R(x,y)) → lim(Y,z) → R(x,z),
  have Ind1 : ∀₀ x ∈ xs, (∀₀ y ∈ xs, R(y,x)) → (∀₀ y ∈ xs, R(x,y)), from
    take x, assume Hx : x ∈ xs, assume RXx : ∀₀ y ∈ xs, R(y,x),
    show ∀₀ y ∈ xs, R(x,y), from
      proof -- by "induction" on y ∈ xs
        let X' := {y ∈ xs | R(x,y)} in
        have Ind1a : inits ⊆ X', from
          take y, assume Hyi : y ∈ inits,
          have y ∈ xs, from cl_inits Hyi,
          show y ∈ X', from and.intro this (Ha Hx Hyi),
        have Ind1b : ∀₀ y ∈ X', ∀ z, succ(y,z) → z ∈ X', from
          take y, assume Hy' : y ∈ X', take z, assume Syz : succ(y,z),
          have Hy : y ∈ xs, from and.left Hy',
          have Rxy : R(x,y), from and.right Hy',
          have Hz : z ∈ xs, from cl_succ Hy Syz,
          have R(x,z), from Hb Hx Hy Rxy (RXx Hy) Syz,
          show z ∈ X', from and.intro Hz this,
        have Ind1c : ∀ Y z, Y ⊆ X' → lim(Y,z) → z ∈ X', from
          take Y z, assume YsubX' : Y ⊆ X', assume LYz : lim(Y,z),
          have HY : Y ⊆ xs, from λ y Hy, and.left (YsubX' Hy),
          have RxY : ∀₀ y ∈ Y, R(x,y), from λ y Hy, and.right (YsubX' Hy),
          have Hz : z ∈ xs, from cl_lim HY LYz,
          have R(x,z), from Hc Hx HY RxY LYz,
          show z ∈ X', from and.intro Hz this,
        have xs ⊆ X', from ind X' Ind1a Ind1b Ind1c,
        show ∀₀ y ∈ xs, R(x,y), from λ y Hy, and.right (this Hy)
      qed,
  have Ind2 : ∀₀ x ∈ xs, ∀₀ w ∈ xs, R(w,x), from
    proof -- by "induction" on x ∈ xs
      let X' := {x ∈ xs | ∀₀ w ∈ xs, R(w,x)} in
      have Ind2a : inits ⊆ X', from
        take x, assume Hxi : x ∈ inits,
        have Hx : x ∈ xs, from cl_inits Hxi,
        have ∀₀ w ∈ xs, R(w,x), from
          take w, suppose w ∈ xs,
          show R(w,x), from Ha this Hxi,
        show x ∈ X', from and.intro Hx this,
      have Ind2b : ∀₀ y ∈ X', ∀ z, succ(y,z) → z ∈ X', from
        take y, assume Hy' : y ∈ X', take z, assume Syz : succ(y,z),
        have Hy : y ∈ xs, from and.left Hy',
        have RXy : ∀₀ w ∈ xs, R(w,y), from and.right Hy',
        have Hz : z ∈ xs, from cl_succ Hy Syz,
        have ∀₀ w ∈ xs, R(w,z), from
          take w, suppose w ∈ xs,
          show R(w,z), from Hb this Hy (RXy this) (Ind1 Hy RXy this) Syz,
        show z ∈ X', from and.intro Hz this,
      have Ind2c : ∀ Y z, Y ⊆ X' → lim(Y,z) → z ∈ X', from
        take Y z, assume YsubX' : Y ⊆ X', assume LYz : lim(Y,z),
        have HY : Y ⊆ xs, from λ y Hy, and.left (YsubX' Hy),
        have RXY : ∀₀ y ∈ Y, ∀₀ w ∈ xs, R(w,y), from
          λ y Hy, and.right (YsubX' Hy),
        have Hz : z ∈ xs, from cl_lim HY LYz,
        have ∀₀ x ∈ xs, R(x,z), from
          take x, assume Hx : x ∈ xs,
          have RxY : ∀₀ y ∈ Y, R(x,y), from λ y Hy, RXY Hy Hx,
          show R(x,z), from Hc Hx HY RxY LYz,
        show z ∈ X', from and.intro Hz this,
      have xs ⊆ X', from ind X' Ind2a Ind2b Ind2c,
      show ∀₀ x ∈ xs, ∀₀ w ∈ xs, R(w,x), from λ x Hx, and.right (this Hx)
    qed,
  show ∀₀ x ∈ xs, ∀₀ y ∈ xs, R(x,y), from
    take x, assume Hx, take y, assume Hy, Ind2 Hy Hx
end


-- choice types and classically well-ordered types

structure has_choice [class] (X : Type) :=
  (c       : set X → set X)
  (incl    : ∀ Y, c Y ⊆ Y)
  (subsing : ∀ Y x₁ x₂, x₁ ∈ c Y → x₂ ∈ c Y → x₁ = x₂)
  (inh     : ∀ Y, (∃ x, x ∈ Y) → ∃ x, x ∈ c Y)

structure is_cwo [class] (X : Type) extends has_choice X, has_le X :=
  (antisymm : ∀ x₁ x₂, le x₁ x₂ → le x₂ x₁ → x₁ = x₂)
  (least    : ∀ Y x y, x ∈ c Y → y ∈ Y → le x y)


-- classically well-ordered types are linear weak orders

local abbreviation miom := @mem_insert_of_mem
local abbreviation ms := @mem_singleton

section 
  parameters {X : Type} [is_cwo X]
  variables (x y z : X)

  local abbreviation c        := @has_choice.c X
  local abbreviation incl     := @has_choice.incl X
  local abbreviation subsing  := @has_choice.subsing X
  local abbreviation inh      := @has_choice.inh X
  local abbreviation antisymm := @is_cwo.antisymm X
  local abbreviation least    := @is_cwo.least X


  lemma c_insert : ∀ Y, x ∈ c (insert x Y) ∨ ∃₀ y ∈ Y, y ∈ c (insert x Y) :=
    take Y,
    have Hsub : c (insert x Y) ⊆ insert x Y, from incl (insert x Y),
    have ∃ w, w ∈ insert x Y, from exists.intro x (mem_insert x Y),
    have ∃ w, w ∈ c (insert x Y), from inh (insert x Y) this,
    obtain w (Hw : w ∈ c (insert x Y)), from this,
    have w ∈ insert x Y, from mem_of_subset_of_mem Hsub Hw,
    have w = x ∨ w ∈ Y, from eq_or_mem_of_mem_insert this,
    show x ∈ c (insert x Y) ∨ ∃₀ y ∈ Y, y ∈ c (insert x Y), from or.elim this
      (assume Hwx : w = x,
        have x ∈ c (insert x Y), from Hwx ▸ Hw,
        or.inl this)
      (assume HwY : w ∈ Y,
        have w ∈ Y ∧ w ∈ c (insert x Y), from and.intro HwY Hw,
        have ∃₀ y ∈ Y, y ∈ c (insert x Y), from exists.intro w this,
        or.inr this)

  corollary c_sing : x ∈ c '{x} :=
    or.elim (c_insert x ∅) id
      (suppose ∃₀ w ∈ ∅, w ∈ c '{x},
        obtain w (Hw : w ∈ ∅ ∧ w ∈ c '{x}), from this,
        false.elim (and.left Hw))

  corollary c_doub : x ∈ c '{x,y} ∨ y ∈ c '{x,y} :=
    or.elim (c_insert x '{y}) or.inl
      (suppose ∃₀ w ∈ '{y}, w ∈ c '{x,y},
       obtain w (Hw : w ∈ '{y} ∧ w ∈ c '{x,y}), from this,
       have w = y, from eq_of_mem_singleton (and.left Hw),
       or.inr (this ▸ (and.right Hw)))

  corollary c_trip : x ∈ c '{x,y,z} ∨ y ∈ c '{x,y,z} ∨ z ∈ c '{x,y,z} :=
    or.elim (c_insert x '{y,z}) or.inl
      (suppose ∃₀ w ∈ '{y,z}, w ∈ c '{x,y,z},
       obtain w (Hw : w ∈ '{y,z} ∧ w ∈ c '{x,y,z}), from this,
       or.elim (eq_or_mem_of_mem_insert (and.left Hw))
         (suppose w = y,
            or.inr (or.inl (this ▸ (and.right Hw))))
         (suppose w ∈ '{z},
            have w = z, from eq_of_mem_singleton this,
            show x ∈ c '{x,y,z} ∨ y ∈ c '{x,y,z} ∨ z ∈ c '{x,y,z}, from
            or.inr (or.inr (this ▸ (and.right Hw)))))
         
  theorem cwo_reflexive : x ≤ x :=
    have x ∈ c '{x}, from c_sing x,
    show x ≤ x, from least '{x} x x this (ms x)

  theorem cwo_linear : x ≤ y ∨ y ≤ x :=
    have x ∈ c '{x,y} ∨ y ∈ c '{x,y}, from c_doub x y,
    or.elim this
      (assume Hx : x ∈ c '{x,y},
        have y ∈ '{x,y}, from miom x (ms y),
        have x ≤ y, from least '{x,y} x y Hx this,
        or.inl this)
      (assume Hy : y ∈ c '{x,y},
        have x ∈ '{x,y}, from mem_insert x '{y},
        have y ≤ x, from least '{x,y} y x Hy this,
        or.inr this)

  theorem cwo_transitive : x ≤ y → y ≤ z → x ≤ z :=
    assume (Hxy : x ≤ y) (Hyz : y ≤ z),
    have x ∈ c '{x,y,z} ∨ y ∈ c '{x,y,z} ∨ z ∈ c '{x,y,z}, from c_trip x y z,
    or.elim this
      (assume Hx : x ∈ c '{x,y,z},
        have z ∈ '{x,y,z}, from miom x (miom y (ms z)),
        show x ≤ z, from least '{x,y,z} x z Hx this)
      (assume Hyorz, or.elim Hyorz
      (assume Hy : y ∈ c '{x,y,z},
        have x ∈ '{x,y,z}, from mem_insert x '{y,z},
        have y ≤ x, from least '{x,y,z} y x Hy this,
        have y = x, from antisymm y x this Hxy,
        show x ≤ z, from this ▸ Hyz)
      (assume Hz : z ∈ c '{x,y,z},
        have y ∈ '{x,y,z}, from miom x (mem_insert y '{z}),
        have z ≤ y, from least '{x,y,z} z y Hz this,
        have y = z, from antisymm y z Hyz this,
        show x ≤ z, from this ▸ Hxy))


  definition is_cwo.to_linear_weak_order [trans_instance] [reducible]
    : linear_weak_order X :=
    ⦃ linear_weak_order, 
        le_refl     := cwo_reflexive,
        le_trans    := cwo_transitive,
        le_antisymm := antisymm,
        le_total    := cwo_linear
    ⦄

end 



---- main proof begins here ----

section main
parameters {B : Type} {C : has_choice B}

local abbreviation c        := @has_choice.c B C
local abbreviation incl     := @has_choice.incl B C
local abbreviation subsing  := @has_choice.subsing B C
local abbreviation inh      := @has_choice.inh B C


-- generalized derived set; I've called it fat_prime here because Zermelo used
-- X' for what we call X^⊥, and we've replaced {⊥} in our proof with all θ ∈ Prop,
-- with θ in X^θ looking like a "fat" prime symbol :-).

definition fat_prime (X : set B) (θ : Prop) : set B := {x ∈ X | x ∈ c X → θ}
local infix `↑`:51 := fat_prime


-- definition of M

definition closed (M : set (set B)) : Prop :=
  univ ∈ M ∧ 
  (∀₀ U ∈ M, ∀ θ, U ↑ θ ∈ M) ∧
  (∀ N, N ⊆ M → sInter N ∈ M)

definition M  : set (set B) := sInter {M | closed M}


-- M is closed

lemma closed_M_univ : univ ∈ M :=
  take M', suppose closed M',
  show univ ∈ M', from and.left this

lemma closed_M_fat_prime : ∀₀ U ∈ M, ∀ θ, U ↑ θ ∈ M :=
  take U, assume HU : U ∈ M, take θ, 
  take M', assume ClM' : closed M',
  have U ∈ M', from HU ClM',
  show U ↑ θ ∈ M', from and.left (and.right ClM') U this θ

lemma closed_M_sInter : ∀ N, N ⊆ M → sInter N ∈ M :=
  take N, assume NsubM : N ⊆ M,
  take M', assume ClM' : closed M',
  have N ⊆ M', from 
    take U, suppose U ∈ N,
    have U ∈ M, from NsubM this,
    show U ∈ M', from this ClM',
  show sInter N ∈ M', from and.right (and.right ClM') N this

lemma closed_M : closed M :=
  and.intro closed_M_univ (and.intro closed_M_fat_prime closed_M_sInter)


-- M has a natural inductive structure

definition xs_M    : set (set B)               := M
definition inits_M : set (set B)               := '{univ}
definition succ_M  : set (set B × set B)       := {U | ∃ θ, U.2 = U.1 ↑ θ}
definition lim_M   : set (set (set B) × set B) := {N | N.2 = sInter N.1}

lemma cl_inits_M : inits_M ⊆ xs_M :=
  take x, suppose x ∈ inits_M,
  have EqU : x = univ, from eq_of_mem_singleton this,
  have univ ∈ M, from closed_M_univ,
  show x ∈ M, from EqU⁻¹ ▸ this

lemma cl_succ_M : ∀₀ y ∈ xs_M, ∀ z, succ_M(y,z) → z ∈ xs_M :=
  take y, assume Hy : y ∈ M, take z, suppose succ_M(y,z),
  obtain θ (Hz : z = y ↑ θ), from this,
  have y ↑ θ ∈ M, from closed_M_fat_prime Hy θ,
  show z ∈ M, from Hz⁻¹ ▸ this

lemma cl_lim_M : ∀ Y z, Y ⊆ xs_M → lim_M(Y,z) → z ∈ xs_M :=
  take Y z, assume YsubM : Y ⊆ xs_M, assume LYz : lim_M(Y,z),
  have sInter Y ∈ M, from closed_M_sInter Y YsubM,
  show z ∈ M, from LYz⁻¹ ▸ this

lemma ind_M : ∀ X',
    inits_M ⊆ X' →
    (∀₀ y ∈ X', ∀ z, succ_M(y,z) → z ∈ X') →
    (∀ {Y z}, Y ⊆ X' → lim_M(Y,z) → z ∈ X') →
      xs_M ⊆ X' :=
  take X',
  assume Ha : inits_M ⊆ X',
  assume Hb : ∀₀ y ∈ X', ∀ z, succ_M(y,z) → z ∈ X',
  assume Hc : ∀ Y z, Y ⊆ X' → lim_M(Y,z) → z ∈ X',
  have H1 : univ ∈ X', from Ha (ms univ),
  have H2 : ∀₀ U ∈ X', ∀ θ, U ↑ θ ∈ X', from
    take U, assume HU : U ∈ X', take θ,
    show U ↑ θ ∈ X', from Hb HU (U ↑ θ) (exists.intro θ rfl),
  have H3 : ∀ N, N ⊆ X' → sInter N ∈ X', from
    take N, suppose N ⊆ X',
    show sInter N ∈ X', from Hc N (sInter N) this rfl,
  have closed X', from and.intro H1 (and.intro H2 H3),
  take x, assume Hx : x ∈ M,
  show x ∈ X', from Hx this
    
definition ind_str_M : ind_str (set B) :=
  ⦃ ind_str,
    xs       := xs_M,
    inits    := inits_M,
    succ     := succ_M,
    lim      := lim_M,
    cl_inits := cl_inits_M,
    cl_succ  := cl_succ_M,
    cl_lim   := cl_lim_M,
    ind      := ind_M
  ⦄


-- Lemma 3.1

lemma choice_sub : ∀₀ U ∈ M, ∀₀ V ∈ M, c U ⊆ V → U ⊆ V :=
  let M0 := inits_M,
      S := succ_M,
      L := lim_M,
      R := λ U, c U.1 ⊆ U.2 → U.1 ⊆ U.2 in
  have Ha : ∀₀ U ∈ M, ∀₀ V ∈ M0, R(U,V), from
    take U, suppose U ∈ M, take V, assume HV : V ∈ M0,
    suppose c U ⊆ V, take x, suppose x ∈ U,
    have V = univ, from eq_of_mem_singleton HV,
    show x ∈ V, from this⁻¹ ▸ mem_univ x,
  have Hb : ∀₀ U ∈ M, ∀₀ V ∈ M, ∀ V', R(U,V) → R(V,U) → S(V,V') → R(U,V'), from
    take U, assume HU : U ∈ M, take V, assume HV : V ∈ M, take V',
    assume (RUV : R(U,V)) (RVU : R(V,U)) (SVV' : S(V,V')) (Hsub : c U ⊆ V'),
    take u, assume Hu : u ∈ U,
    show u ∈ V', from 
      obtain θ (Hθ : V' = V ↑ θ), from SVV',
      have V ↑ θ ⊆ V, from sep_subset V _,
      have V' ⊆ V, from Hθ⁻¹ ▸ this, 
      have c U ⊆ V, from subset.trans Hsub this,
      have UsubV : U ⊆ V, from RUV this,
      have u ∈ V, from UsubV Hu,
      have u ∈ c V → θ, from
        assume Hu' : u ∈ c V,
        have c V ⊆ U, from
          take x, suppose x ∈ c V,
          have u = x, from subsing V u x Hu' this,
          show x ∈ U, from this ▸ Hu,
        have V ⊆ U, from RVU this,
        have U = V, from subset.antisymm UsubV this,
        have c V ⊆ V', from this ▸ Hsub,
        have u ∈ V', from this Hu',
        have u ∈ V ↑ θ, from Hθ ▸ this,
        show θ, from and.right this Hu',
      have u ∈ V ↑ θ, from and.intro `u ∈ V` this,
      show u ∈ V', from Hθ⁻¹ ▸ this,
  have Hc : ∀₀ U ∈ M, ∀ N V, N ⊆ M → (∀₀ W ∈ N, R(U,W)) → L(N,V) → R(U,V), from
    take U, assume HU : U ∈ M, take N V,
    assume (Hsub : N ⊆ M) (RUN : ∀₀ W ∈ N, R(U,W)) (LNV : L(N,V)),
    assume (CUV : c U ⊆ V), take u, assume Hu : u ∈ U,
    have u ∈ sInter N, from
      take W, assume HW : W ∈ N,
      have c U ⊆ W, from
        take w, suppose w ∈ c U,
        have w ∈ V, from CUV this,
        have w ∈ sInter N, from LNV ▸ this,
        show w ∈ W, from this HW,
      have U ⊆ W, from RUN HW this,
      show u ∈ W, from this Hu,
    show u ∈ V, from LNV⁻¹ ▸ this,
  show _, from ind_str.smullyan_ind ind_str_M R Ha Hb Hc


-- Lemma 3.2, in five parts

definition R (X : set B) : set B := sInter { Y | Y ∈ M ∧ X ⊆ Y }

lemma sub_X_RX : ∀ X, X ⊆ R X :=
  take X,
  take x, assume Hx : x ∈ X,
  show x ∈ R X, from
    take Y, suppose Y ∈ M ∧ X ⊆ Y,
    show x ∈ Y, from and.right this x Hx

lemma RX_in_M : ∀ X, R X ∈ M :=
  take X, let N := { Y | Y ∈ M ∧ X ⊆ Y } in
  have N ⊆ M, from
    take Y, suppose Y ∈ N,
    show Y ∈ M, from and.left this,
  show R X ∈ M, from closed_M_sInter N this

lemma R_least : ∀ X Y, Y ∈ M → X ⊆ Y → R X ⊆ Y :=
  take X Y, assume (HY : Y ∈ M) (XsubY : X ⊆ Y),
  take x, suppose x ∈ R X,
  show x ∈ Y, from this (and.intro HY XsubY)

lemma cRX_sub_X : ∀ X, c (R X) ⊆ X :=
  take X, let θ := c (R X) ⊆ X in
  have Ha : X ⊆ R X ↑ θ, from
    take x, assume Hx : x ∈ X,
    have x ∈ R X, from sub_X_RX X Hx,
    have x ∈ c (R X) → θ, from
      assume Hx' : x ∈ c (R X),
      show θ, from 
        take y, suppose y ∈ c (R X),
        have x = y, from subsing (R X) x y Hx' this,
        show y ∈ X, from this ▸ Hx,
    show x ∈ R X ↑ θ, from and.intro `x ∈ R X` this,
  have R X ↑ θ ∈ M, from closed_M_fat_prime (RX_in_M X) θ,
  have Hb : R X ⊆ R X ↑ θ, from R_least X (R X ↑ θ) this Ha,
  have c (R X) ⊆ R X, from incl (R X),
  have Hc : c (R X) ⊆ R X ↑ θ, from subset.trans this Hb,
  show c (R X) ⊆ X, from 
    take x, assume Hx : x ∈ c (R X),
    have x ∈ R X ↑ θ, from Hc Hx,
    have x ∈ c (R X) → θ, from and.right this,
    have θ, from this Hx,
    show x ∈ X, from this Hx
    
lemma RX_inh_X_inh : ∀ X, (∃ y, y ∈ R X) → ∃ y, y ∈ X :=
  take X, suppose ∃ y, y ∈ R X,
  have ∃ x, x ∈ c (R X), from inh (R X) this,
  obtain x (Hx : x ∈ c (R X)), from this,
  have x ∈ X, from cRX_sub_X X Hx,
  show ∃ y, y ∈ X, from exists.intro x this
  

-- cR := c o R is a choice funciton on B

definition cR (U : set B) := c (R U)

corollary cR_incl : ∀ U, cR U ⊆ U := cRX_sub_X

lemma cR_subsing : ∀ U x₁ x₂, x₁ ∈ cR U → x₂ ∈ cR U → x₁ = x₂ :=
  take U x₁ x₂, assume (Hx₁ : x₁ ∈ cR U) (Hx₂ : x₂ ∈ cR U),
  show x₁ = x₂, from subsing (R U) x₁ x₂ Hx₁ Hx₂

corollary cR_inh : ∀ U, (∃ u, u ∈ U) → ∃ u, u ∈ cR U :=
  take U, suppose ∃ u, u ∈ U,
  obtain u (Hu : u ∈ U), from this,
  have u ∈ R U, from sub_X_RX U Hu,
  have ∃ u, u ∈ R U, from exists.intro u this,
  show ∃ u, u ∈ cR U, from inh (R U) this


-- Lemma 3.3, in two parts

definition le_B (x : B) (y : B) := ∀₀ U ∈ M, x ∈ U → y ∈ U

lemma le_B_antisymm : ∀ x y : B, le_B x y → le_B y x → x = y :=
  take x y, assume (lexy : le_B x y) (leyx : le_B y x),
  let V := R '{x,y}, V' := V ↑ (x = y) in
  have Ha : '{x,y} ⊆ V, from sub_X_RX '{x,y},
  have Hb : V ∈ M, from RX_in_M '{x,y},
  have Hc : V' ∈ M, from closed_M_fat_prime Hb (x = y),
  have Hd : c V ⊆ '{x,y}, from cRX_sub_X '{x,y},
  have Hx : x ∈ V, from Ha (mem_insert x '{y}),
  have Hy : y ∈ V, from Ha (miom x (mem_insert y ∅)),
  have ∃ z, z ∈ c V, from inh V (exists.intro x Hx),
  obtain z (Hz : z ∈ c V), from this,
  have z ∈ '{x,y}, from Hd Hz,
  show x = y, from or.elim (eq_or_mem_of_mem_insert this)
   (suppose Hzx : z = x,
     have y ∈ c V → x = y, from
       suppose y ∈ c V,
       have y = z, from subsing V y z this Hz,
       show x = y, from Hzx⁻¹ ⬝ this⁻¹,
     have y ∈ V', from and.intro Hy this,
     have x ∈ V', from leyx Hc this,
     show x = y, from and.right this (Hzx ▸ Hz))
   (suppose z ∈ '{y},
     have Hzy : z = y, from eq_of_mem_singleton this,
     have x ∈ c V → x = y, from
       suppose x ∈ c V,
       have x = z, from subsing V x z this Hz,
       show x = y, from this ⬝ Hzy,
     have x ∈ V', from and.intro Hx this,
     have y ∈ V', from lexy Hc this,
     show x = y, from and.right this (Hzy ▸ Hz))

lemma le_B_least : ∀ Y x y, x ∈ c (R Y) → y ∈ Y → le_B x y :=
  take Y x y, assume (Hx : x ∈ c (R Y)) (Hy : y ∈ Y),
  take U, assume (HU : U ∈ M) (Hx' : x ∈ U),
  show y ∈ U, from
    have c (R Y) ⊆ U, from
      take z, assume Hz : z ∈ c (R Y),
      have x = z, from subsing (R Y) x z Hx Hz,
      show z ∈ U, from this ▸ Hx',
    have Ha : R Y ⊆ U, from choice_sub (RX_in_M Y) HU this,
    have y ∈ R Y, from sub_X_RX Y Hy,
    show y ∈ U, from Ha this
     

-- main result:  B is well-ordered by cR

definition is_cwo_B : is_cwo B :=
  ⦃ is_cwo,
    c        := cR,
    incl     := cR_incl,
    subsing  := cR_subsing,
    inh      := cR_inh,
    antisymm := le_B_antisymm,
    least    := le_B_least
  ⦄


-- Q: How do I get these as corollaries of the main result?

corollary le_B_refl {x : B} : le_B x x :=
  take U, assume (HU : U ∈ M) (Hx : x ∈ U),
  show x ∈ U, from Hx

corollary le_B_trans {x y z : B} : le_B x y → le_B y z → le_B x z :=
  assume (lexy : le_B x y) (leyz : le_B y z),
  take U, assume (HU : U ∈ M) (Hx : x ∈ U),
  have y ∈ U, from lexy HU Hx,
  show z ∈ U, from leyz HU this


-- Coda: Proposition 3.4 in four parts

lemma has_choice.mem : ∀ Y, ∀₀ x ∈ c Y, c Y = '{x} :=
  take Y x, assume Hx : x ∈ c Y,
  ext (take y, iff.intro
    (suppose y ∈ c Y,
      have y = x, from subsing Y y x this Hx,
      show y ∈ '{x}, from this⁻¹ ▸ (mem_singleton x))
    (suppose y ∈ '{x},
      have y = x, from eq_of_mem_singleton this,
      show y ∈ c Y, from this⁻¹ ▸ Hx))

proposition le_B_R (x y : B) : le_B x y ↔ y ∈ R '{x} :=
  iff.intro
    (assume lexy : le_B x y,
      have '{x} ⊆ R '{x}, from sub_X_RX '{x},
      have Hx : x ∈ R '{x}, from this (mem_singleton x),
      have R '{x} ∈ M, from RX_in_M '{x},
      show y ∈ R '{x}, from lexy this Hx)
    (assume leyR : y ∈ R '{x},
      take U, assume (HUM : U ∈ M) (Hx : x ∈ U),
      have '{x} ⊆ U, from 
        take z, suppose z ∈ '{x},
        have z = x, from eq_of_mem_singleton this,
        show z ∈ U, from this⁻¹ ▸ Hx,
      have R '{x} ⊆ U, from R_least '{x} U HUM this,
      show y ∈ U, from this leyR)

definition upper_closed (X : set B) := ∀₀ x ∈ X, ∀ y, le_B x y → y ∈ X

proposition M_le_B : M = { X | upper_closed X } :=
  ext (take X, iff.intro
    (assume HXM : X ∈ M,
      show ∀₀ x ∈ X, ∀ y, le_B x y → y ∈ X, from
        take x, assume Hx : x ∈ X, take y, assume lexy : le_B x y,
        show y ∈ X, from lexy HXM Hx)
    (assume HX : ∀₀ x ∈ X, ∀ y, le_B x y → y ∈ X,
      have Req : X = R (cR X), from ext (take x, iff.intro
        (assume Hx : x ∈ X,
          have ∃ x, x ∈ X, from exists.intro x Hx,
          have ∃ cRX, cRX ∈ cR X, from cR_inh X this,
          obtain cRX (HcRX : cRX ∈ cR X), from this,
          have le_B cRX x, from le_B_least X cRX x HcRX Hx,
          have Hx' : x ∈ R '{cRX}, from iff.elim_left (le_B_R cRX x) this,
          have cR X = '{cRX}, from has_choice.mem (R X) HcRX,
          show x ∈ R (cR X), from this⁻¹ ▸ Hx')
        (assume Hx : x ∈ R (cR X),
          have ∃ x, x ∈ R (cR X), from exists.intro x Hx,
          have ∃ x, x ∈ cR X, from RX_inh_X_inh (cR X) this,
          obtain cRX (HcRX : cRX ∈ cR X), from this,
          have cR X = '{cRX}, from has_choice.mem (R X) HcRX,
          have x ∈ R '{cRX}, from this ▸ Hx,          
          have Hle : le_B cRX x, from iff.elim_right (le_B_R cRX x) this,
          have cRX ∈ X, from cRX_sub_X X HcRX,
          show x ∈ X, from HX this x Hle)),
      have R (cR X) ∈ M, from RX_in_M (cR X),
      show X ∈ M, from Req⁻¹ ▸ this))

proposition R_le_B : ∀ X, R X = { y | ∃₀ x ∈ X, le_B x y } :=
  take X,
  let R' := { y | ∃₀ x ∈ X, le_B x y } in
  have UCR' : upper_closed R', from
    take y, assume Hy : y ∈ R', take z, assume leyz : le_B y z,
    obtain x (Hx : x ∈ X ∧ le_B x y), from Hy,
    have le_B x z, from le_B_trans (and.right Hx) leyz,
    show z ∈ R', from exists.intro x (and.intro (and.left Hx) this),
  have HR' : ∀ Y, X ⊆ Y → upper_closed Y → R' ⊆ Y, from
    take Y, assume (XsubY : X ⊆ Y) (UCY : upper_closed Y),
    take y, assume Hy : y ∈ R',
    obtain x (Hx : x ∈ X ∧ le_B x y), from Hy,
    have x ∈ Y, from XsubY (and.left Hx),
    show y ∈ Y, from UCY this y (and.right Hx),
  have R' ∈ { X | upper_closed X }, from UCR',
  have Ha : R' ∈ M, from M_le_B⁻¹ ▸ this,
  have X ⊆ R', from
    take x, suppose x ∈ X,
    show x ∈ R', from exists.intro x (and.intro this le_B_refl),
  have Hb : R X ⊆ R', from R_least X R' Ha this,
  have upper_closed (R X), from M_le_B ▸ (RX_in_M X),
  have Hc : R' ⊆ R X, from HR' (R X) (sub_X_RX X) this,
  show _, from subset.antisymm Hb Hc    

end main
